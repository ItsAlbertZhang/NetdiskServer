# 项目开发手册

## 项目需求

#### 一期工程

1. 实现服务端与客户端的连接, 能响应客户端的简单命令.

* 进入对应目录
* 列出目录下的文件
* 下载目录下的文件
* 上传目录下的文件
* 删除目录下的文件
* 显示当前目录

#### 二期工程

1. 实现用户管理系统, 包括:

* 用户的注册与登录
* 为每个用户单独维护目录与文件
* 保证用户连接时的安全性

2. 实现服务端的日志记录.

3. 实现断点续传功能.

4. 在传输大文件时, 使用高效传输策略 (如 mmap 或 sendfile/splice)

#### 三期工程

1. 将用户管理系统升级为数据库依赖, 使用数据库管理用户信息.

2. 将文件系统升级为数据库依赖, 使用数据库管理文件, 并实现文件秒传.

#### 四期工程

1. 实现长响应时间(上传/下载)命令与短响应时间(进入目录等)命令的异步分离.

2. 当客户端长时间无操作时, 服务端自动断开.

#### 其他功能

1. 对大文件实现 UDP 协议传输.

2. 服务端能够响应简单的命令.

## 项目设计

### 功能设计

针对需求中对功能提出的要求, 进行以下设计:

#### 身份验证

##### 注册与登录

服务端保存一对 RSA 密钥, 客户端在初次连接服务端时, 会向服务端发出 REQCONF 请求. 服务端在接收到此请求后, 会随机生成一段用于随后注册或登录的 **确认码** , 并将其与 RSA 公钥一并发送给客户端.

客户端会在询问用户后将接收到的公钥保存在本地. 在下一次启动客户端向服务器发出 REQCONF 请求之前, 客户端会先尝试读取本地公钥, 如果成功读取则会在 REQCONF 请求中将公钥的 MD5 校验码发送给服务端, 服务端会核验该 MD5 校验码, 若核验通过则不再向客户端发送公钥.

在注册或登录时, 客户端会将密码与 **确认码** 进行异或后, 使用 RSA 公钥进行加密并发送至服务端. 服务端在使用私钥解密后, 再用 **确认码** 进行异或即可获得密码明文.

**禁止在任何情况下将密码明文保存至磁盘. 在密码明文使用完毕后, 务必清除内存.**

注册: 服务端在获得密码明文后, 随机生成一段长度为 8 个字节的字符串作为 salt, 并使用该 salt 将密码明文以 SHA512 加密方式获取密文, 随后将密文存储至数据库. (密文中包括 salt)

登录: 服务端在获得密码明文后, 从数据库中获取密文, 使用密文中的 salt 将密码明文加密并与密文进行对比, 即可验证客户端身份.

对应的数据库资源: user_auth.tab

##### 短校验

由于在设计上服务端会在客户端长时间无操作时关闭连接(详见[空闲处理](#空闲处理)), 且客户端在每次长命令拉起线程时都需要新建一个连接(详见[线程池](#线程池)), 因此新连接的建立较为频繁.

[注册与登录](#注册与登录)功能每次在建立新连接时都需要客户端与服务器进行两次双向通信, 且服务端访问数据库时间开销较大. 可以通过短校验的方式来简化这一操作.

在客户端运行后初次连接服务端时(即进行 REQCONF 操作时), 客户端会准备一对 RSA 密钥对, 并将这一对密钥的公钥 (注意:不是服务端公钥) 随 REQCONF 消息发送至服务端. 

服务端会将 `服务端的连接文件描述符`, `初次连接时间` 使用接收到的 **客户端公钥** 进行加密, 并将密文发送给客户端. 客户端接收后对其解密, 这段文本即作为 token 使用.

客户端建立新连接时, 只需将 token 使用 **服务端公钥** 发送给服务端. 服务端在接收到 token 后, 使用 **服务端私钥** 进行解密, 随后在 **现有连接** 中寻找连接文件描述符与 ip 地址均相符的连接, 或在 **休眠连接** 中寻找初次连接时间与 ip 地址均相符的连接, 即可验证客户端身份.

#### 文件系统

需求数据库资源: 文件信息表

#### 线程池

命令可以根据所用时长被分为两类: 上传/下载命令用时较长, 称为 `长命令`, 其余命令则称为 `短命令` .

服务端主线程负责响应来自所有客户端的短命令, 每个子线程单独负责响应来自一个客户端的长命令.

客户端在用户输入命令时对命令进行解析. (做点正事吧客户端) 如果命令为短命令则使用主线程与服务端进行通信, 如果命令为长命令则拉起一个子线程负责该长命令的执行.

客户端主线程可以响应命令 `showpg` , 当用户输入该命令时每秒刷新一次子线程进度.

#### 空闲处理

使用时间轮定时器可以实现客户端的超时自动断开.

以超过 30 秒未操作自动断开为例, 使用一个大小为 30 的循环队列 (30 个时间片), 并将 epoll 的等待时间设定为 1 秒.

每当客户端操作时, 将其从定时器中之前的时间片中拿出, 放在最新的时间片中. 每次从 epoll 中唤醒时, 检查当前时间. 如果与上一次不同, 则切换至下一时间片. 如果下一时间片中存在客户端连接, 则说明该客户端已超时, 可以断开连接并将其放至休眠连接中.

##### 自动重连

断开 socket 连接后, 连接会从 `现有连接` 移动至 `休眠连接` 中. 在休眠状态下时, 客户端可以通过短校验直接重新连接, 而无需输入密码.

### 流程设计

详见 Manual.png / Manual.pdf / Manual.xmind (暂未上传).

.png - 便于在线查看的图片版本.

.pdf - 便于对文字进行复制的文档版本.

.xmind - XMind 软件的源文件版本.

### 协议设计

对于下文一些专有名词的解释:

连接状态: `struct connect_stat_t` .

#### 客户端与服务端之间的通信消息需严格遵守以下格式:

- 1 个字节的消息类型标志. 该标志定义于 `enum msg_type` .

- 若干个数据段:

  - 4 个字节的数据内容的长度. 当数据省略时, 该字段的值为 0.

  - 数据内容. (部分情况下置空)

#### 下发验证请求

客户端向服务端发出下发验证请求的消息类型标志 `MT_REQCONF`. 服务端接收并进行解析后进入对应功能函数.

客户端向服务端发送一个数据段, 数据内容为客户端本地保存的服务端公钥的 MD5 校验码. 如果客户端本地未在程序初始化阶段在本地成功获取服务端公钥, 则该数据内容置空.

服务端接收消息后, 首先生成一段长度为 30 字节的随机字符串(会话确认码). 随后, 服务端对本地保存的公钥进行读取, 并计算其 MD5 校验码进行对比. 随后, 服务端发送两个数据段:

- 第一个数据段为会话确认码.

- 第二个数据段为服务端公钥. 如果在之前的比对中发现接收到来自客户端的 MD5 校验码与服务端计算本地公钥得出的 MD5 校验码一致, 则该段置空.